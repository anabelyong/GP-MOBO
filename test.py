import numpy as np
import matplotlib.pyplot as plt
from acquisition_funcs.hypervolume import Hypervolume, infer_reference_point
from acquisition_funcs.pareto import pareto_front  

# Define the objective functions
def f1(x):
    return x[0]**2 + x[1]**2

def f2(x):
    return (x[0] - 1)**2 + x[1]**2

def f3(x):
    return x[0]**2 + (x[1] - 1)**2

# MOMCMC sampling function
def momcmc_sampling(n_samples, n_iterations, temperature, desired_acceptance, ref_point):
    population = np.random.rand(n_samples, 2)  # Initialize random solutions
    acceptance_rate = 0.0
    hv = Hypervolume(ref_point)  # Initialize Hypervolume with the reference point

    for iteration in range(n_iterations):
        new_population = np.empty_like(population)
        for i in range(n_samples):
            sample_idx = np.random.randint(n_samples)
            new_solution = population[sample_idx] + temperature * np.random.randn(2)
            new_solution = np.clip(new_solution, 0, 1)
            new_population[i] = new_solution

        # Evaluate the objective functions
        objectives_pop = np.array([[f1(sol), f2(sol), f3(sol)] for sol in population])
        objectives_new = np.array([[f1(sol), f2(sol), f3(sol)] for sol in new_population])

        pareto_pop_mask = pareto_front(objectives_pop, maximize=False)
        pareto_new_mask = pareto_front(objectives_new, maximize=False)
        pareto_pop = objectives_pop[pareto_pop_mask]
        pareto_new = objectives_new[pareto_new_mask]

        if hv.compute(pareto_new) > hv.compute(pareto_pop):
            population = new_population

        acceptance_rate = np.mean(np.all(new_population == population, axis=1))
        if acceptance_rate < desired_acceptance:
            temperature *= 1.1
        else:
            temperature *= 0.9

    return population

# Apply MOMCMC method
n_samples = 4096
n_iterations = 100
temperature = 1.0
desired_acceptance = 0.15
ref_point = np.array([2, 2, 2])  # Define the reference point
solutions = momcmc_sampling(n_samples, n_iterations, temperature, desired_acceptance, ref_point)

# Evaluate the objective functions
objectives = np.array([[f1(sol), f2(sol), f3(sol)] for sol in solutions])

# Plot the solutions in the objective function space
fig = plt.figure(figsize=(10, 7))
ax = fig.add_subplot(111, projection='3d')
ax.scatter(objectives[:, 0], objectives[:, 1], objectives[:, 2], c='blue', s=1)

ax.set_xlabel('f1')
ax.set_ylabel('f2')
ax.set_zlabel('f3')
plt.title('Population of 4096 solutions generated by MOMCMC')

plt.show()
